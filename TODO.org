* Notebooks [0/6]
  - [ ] Maybe monad
  - [ ] Tree functor
  - [ ] Result monad
  - [ ] Functor
  - [ ] Monad
  - [ ] Degrees of magic (README prototype)


* REFACTORING [0/5]
  - [ ] normalize Expression.__init__ arguments keeping  [0/0]
    As of now, almost all subclasses of Expression
    can implement _run_ and other protocols by simply
    reconstructing itself with mappend arguments, that is not
    the case with subclasses with kwargs thou

  - [ ] Align every protocol that uses `f(object) [*mapping]` syntax to
        accept alternative `f(object, mapping)` the same way `substitute` does


  - [ ] Adds __hash__ to Placeholder objects instead of that memoize thing?
        Create an issue for this, it may be better to memoize with weakmap,
        giving a Placeholder can have unhasheables in the annotation or default


  - [ ] Util [0/2]
    - [ ] `records [a: b, c: d]` -> [(a, b), (c, d)]
    - [ ] `mapping [a: b, c: d]` -> UnhasheableKeysMapping([(a, b), (c, d)])


  - [ ] match and case better API [0/3]
    - [ ] handling of ellipsis is cumbersome,
          decide a general handling for it,
          either special case it unconditionaly of
          user implementation of _case_ and _match_
          or add a decorator @accept_ellipsis or something
          or make `placeholder` a placeholder instance itself,
          therefore always matching and ditching ellipsis

          NOTE: in order to make `match` independent of
                placeholder, keeping ellipsis is desirable

    - [ ] Add a util to reverse matches, ie
          [(2, `x), (3, `y)] -> [(`x, 2), (`y, 3)]

    - [ ] Add a fmap to handle any sequence consistently

    - [ ] problem with string handling in _case_,
          the current algorith is generic for Sequence
          in which it handles its items recursevily,
          but string are made of strings (in other
          languages they are made of char), causing infinite
          recursion

* tilde [0/2]
  - [ ] Add __iter__ to atom, so it returns *args
  - [ ] Adds ~ operator to atom, so it returns version with public params
  - [ ] placeholder(function) and placeholder(arg, *args, kwarg, **kwargs)


* TESTING [0/1]
  - [ ] Placeholder [0/3]
    - [ ] constructors
    - [ ] uniqueness
    - [ ] repr

  - [ ] match [/]
    - [ ] builtin
